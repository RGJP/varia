<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mandala Maker</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>%E2%9C%BF</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #050510;
            --text: #e0e7ff;
            --text-dim: rgba(255, 255, 255, 0.5);
            --primary: #a5b4fc;
            --primary-glow: rgba(165, 180, 252, 0.4);
            --glass: rgba(255, 255, 255, 0.06);
            --glass-border: rgba(255, 255, 255, 0.1);
            --glass-hover: rgba(255, 255, 255, 0.15);
            --danger: #f87171;
        }

        *,
        *::before,
        *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background-color: var(--bg-deep);
            color: var(--text);
            font-family: 'Outfit', sans-serif;
            height: 100dvh;
            overflow: hidden;
            cursor: crosshair;
            display: flex;
            justify-content: center;
            align-items: center;
            touch-action: none;
        }

        /* ── Canvas Container ── */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            touch-action: none;
            /* We will animate transform on this container */
            will-change: transform;
            /* Origin center to match the mandala's coordinate system */
            transform-origin: center center;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            display: block;
            width: 100%;
            height: 100%;
        }

        #canvas-active {
            pointer-events: none;
            /* Let touches pass through to container */
        }

        /* ── UI Overlay ── */
        .ui-overlay {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 0.75rem;
            padding: 0.75rem 1.5rem;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 50px;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            align-items: center;
            transition: opacity 0.4s ease, transform 0.4s ease;
            z-index: 10;
        }

        body.drawing .ui-overlay {
            opacity: 0.15;
            pointer-events: none;
            transform: translateX(-50%) translateY(8px);
        }

        body.idle .ui-overlay {
            opacity: 0.25;
            transform: translateX(-50%) translateY(8px);
        }

        body.idle .ui-overlay:hover,
        body.drawing .ui-overlay:hover {
            opacity: 1;
            pointer-events: auto;
            transform: translateX(-50%) translateY(0);
        }

        .divider {
            width: 1px;
            height: 24px;
            background: var(--glass-border);
            flex-shrink: 0;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        label {
            font-size: 0.75rem;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--text-dim);
            user-select: none;
            white-space: nowrap;
        }

        .value-badge {
            font-size: 0.7rem;
            font-weight: 500;
            min-width: 1.5em;
            text-align: center;
            color: var(--primary);
        }

        /* ── Select Dropdown ── */
        select {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            color: var(--text);
            padding: 0.3rem 0.6rem;
            border-radius: 12px;
            font-family: inherit;
            font-size: 0.8rem;
            cursor: pointer;
            outline: none;
            transition: all 0.2s ease;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6' fill='none'%3E%3Cpath stroke='rgba(255,255,255,0.5)' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m1 1 4 4 4-4'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
            padding-right: 30px;
        }

        select:hover {
            background: var(--glass-hover);
            border-color: var(--primary);
            box-shadow: 0 0 8px rgba(165, 180, 252, 0.1);
        }

        select:focus-visible {
            border-color: var(--primary);
            box-shadow: 0 0 0 2px var(--primary-glow);
        }

        select option {
            background: #0f172a;
            /* Deep blue-black for dropdown menu */
            color: var(--text);
        }

        /* ── Buttons ── */
        button {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: var(--text);
            padding: 0.4rem 0.85rem;
            border-radius: 20px;
            font-family: inherit;
            font-weight: 400;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            white-space: nowrap;
            user-select: none;
        }

        button:hover {
            background: var(--glass-hover);
            border-color: var(--primary);
            box-shadow: 0 0 12px rgba(165, 180, 252, 0.15);
        }

        button:active {
            transform: scale(0.96);
        }

        button:focus-visible {
            outline: 2px solid var(--primary);
            outline-offset: 2px;
        }

        button.active {
            background: var(--primary);
            color: #0a0a1a;
            font-weight: 500;
            border-color: var(--primary);
            box-shadow: 0 0 16px var(--primary-glow);
        }

        button.danger-confirm {
            border-color: var(--danger);
            color: var(--danger);
            animation: pulse-danger 0.6s ease;
        }

        @keyframes pulse-danger {

            0%,
            100% {
                box-shadow: none;
            }

            50% {
                box-shadow: 0 0 12px rgba(248, 113, 113, 0.3);
            }
        }

        /* ── Color Picker ── */
        .color-picker {
            display: flex;
            gap: 0.4rem;
            align-items: center;
        }

        .color-option {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.2s ease, border-color 0.2s ease;
            flex-shrink: 0;
        }

        .color-option:hover {
            transform: scale(1.15);
        }

        .color-option.selected {
            border-color: #fff;
            transform: scale(1.15);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.2);
        }

        .color-custom {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            transition: transform 0.2s ease, border-color 0.2s ease;
        }

        .color-custom:hover {
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.15);
        }

        .color-custom.selected {
            border-style: solid;
            border-color: #fff;
            transform: scale(1.15);
        }

        .color-custom input[type=color] {
            position: absolute;
            inset: -8px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            opacity: 0;
        }

        /* ── Tip / Onboarding ── */
        .tip {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.15);
            font-size: 1rem;
            pointer-events: none;
            opacity: 1;
            transition: opacity 0.8s ease;
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        .tip.hidden {
            opacity: 0;
        }



        /* ── Toast Notification ── */
        .toast {
            position: fixed;
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%) translateY(-20px);
            background: var(--glass);
            border: 1px solid var(--glass-border);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            padding: 0.5rem 1.2rem;
            border-radius: 20px;
            font-size: 0.75rem;
            color: var(--text);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease, transform 0.3s ease;
            z-index: 20;
            letter-spacing: 0.04em;
        }

        .toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        /* ── Responsive ── */
        @media (max-width: 800px) {
            .ui-overlay {
                width: calc(100% - 2rem);
                flex-wrap: wrap;
                justify-content: center;
                padding: 0.6rem 0.8rem;
                bottom: 0.75rem;
                border-radius: 16px;
                gap: 0.5rem;
            }

            .divider {
                display: none;
            }

            .control-group {
                gap: 0.3rem;
            }

            label {
                font-size: 0.65rem;
            }

            button {
                padding: 0.35rem 0.65rem;
                font-size: 0.65rem;
            }

            select {
                padding: 0.25rem 0.5rem;
                font-size: 0.75rem;
                padding-right: 24px;
                background-position: right 6px center;
            }

            .color-option,
            .color-custom {
                width: 20px;
                height: 20px;
            }


        }

        @media (max-width: 400px) {
            .ui-overlay {
                padding: 0.5rem;
                gap: 0.4rem;
            }
        }
    </style>
</head>

<body>
    <div class="tip" id="startTip">Click & drag to draw</div>
    <div id="canvas-container">
        <canvas id="canvas-static"></canvas>
        <canvas id="canvas-active"></canvas>
    </div>



    <div class="toast" id="toast" role="status" aria-live="polite"></div>

    <div class="ui-overlay" role="toolbar" aria-label="Drawing controls">
        <div class="control-group">
            <button id="fullscreenBtn" title="Enter Fullscreen" aria-label="Toggle Fullscreen"
                style="padding: 0.35rem 0.5rem; min-width: 2.4rem; font-weight: 500; letter-spacing: -1px; display: flex; align-items: center; justify-content: center; font-size: 0.9rem;">[
                + ]</button>
            <label for="symmetryRange">Sym</label>
            <select id="symmetryRange" aria-label="Symmetry fold count"></select>
        </div>

        <div class="control-group">
            <label for="brushRange">Size</label>
            <select id="brushRange" aria-label="Brush size"></select>
        </div>

        <div class="divider"></div>

        <div class="control-group">
            <button id="mirrorBtn" title="Toggle mirror reflection" aria-pressed="false">Mirror</button>
        </div>

        <div class="divider"></div>

        <div class="control-group color-picker" id="colorPicker" role="radiogroup" aria-label="Color palette"></div>

        <div class="divider"></div>

        <div class="control-group">
            <button id="undoBtn" title="Undo Last Stroke" aria-label="Undo">Undo</button>
            <button id="redoBtn" title="Redo Last Stroke" aria-label="Redo">Redo</button>
            <button id="clearBtn" title="Clear Canvas" aria-label="Clear canvas">Clear</button>
            <button id="saveBtn" title="Save as PNG" aria-label="Save as PNG">Save</button>
        </div>
    </div>

    <script>
        (() => {
            'use strict';

            // ── DOM References ──
            const canvasContainer = document.getElementById('canvas-container');
            const canvasStatic = document.getElementById('canvas-static');
            const canvasActive = document.getElementById('canvas-active');
            const ctxStatic = canvasStatic.getContext('2d', { willReadFrequently: false, alpha: false });
            const ctxActive = canvasActive.getContext('2d', { willReadFrequently: false, alpha: true });
            const $ = id => document.getElementById(id);
            const symmetryRange = $('symmetryRange');
            const brushRange = $('brushRange');
            const mirrorBtn = $('mirrorBtn');
            const clearBtn = $('clearBtn');
            const saveBtn = $('saveBtn');
            const undoBtn = $('undoBtn');
            const redoBtn = $('redoBtn');
            const colorPicker = $('colorPicker');
            const startTip = $('startTip');
            const toast = $('toast');
            const fullscreenBtn = $('fullscreenBtn');

            // ── Populate Selects ──
            for (let i = 2; i <= 32; i++) {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = i;
                if (i === 6) opt.selected = true; // Match state default
                symmetryRange.appendChild(opt);
            }
            for (let i = 1; i <= 20; i++) {
                const opt = document.createElement('option');
                opt.value = i;
                opt.textContent = i;
                if (i === 2) opt.selected = true; // Match state default
                brushRange.appendChild(opt);
            }

            // ── State ──
            const state = {
                drawing: false,
                symmetry: 6,
                brushSize: 2,
                hue: 0,
                mirrorMode: false,
                lastDrawTime: 0,

                // Viewport State (Committed)
                scale: 1,
                offsetX: 0, // Pan Offset X
                offsetY: 0, // Pan Offset Y

                // Gesture State (Transient)
                gestureScale: 1,
                gestureX: 0,
                gestureY: 0,

                hasDrawn: false,
                clearPending: false,
                clearTimer: null,
                touchDelayTimer: null,
                bufferedEvents: [],
            };

            // ── Stroke Storage ──
            const strokes = [];
            let currentStroke = null;

            // ── History ──
            const history = {
                stack: [],
                index: -1,
                maxSize: 50,
                push() {
                    this.stack.length = this.index + 1;
                    const snapshot = strokes.map(s => ({
                        ...s,
                        points: [...s.points],
                        colors: s.colors ? [...s.colors] : []
                    }));
                    this.stack.push(snapshot);
                    if (this.stack.length > this.maxSize) this.stack.shift();
                    else this.index++;
                    this.updateButtons();
                },
                undo() {
                    if (this.index <= 0) return;
                    this.index--;
                    this.restore();
                },
                redo() {
                    if (this.index >= this.stack.length - 1) return;
                    this.index++;
                    this.restore();
                },
                restore() {
                    strokes.length = 0;
                    const snapshot = this.stack[this.index];
                    for (const s of snapshot) {
                        strokes.push({
                            ...s,
                            points: [...s.points],
                            colors: s.colors ? [...s.colors] : []
                        });
                    }
                    requestRender();
                    this.updateButtons();
                    const msg = this.index === 0 ? 'Undo (Empty)' : `Undo/Redo (${this.index})`;
                    showToast(msg);
                },
                clear() {
                    this.stack = [];
                    this.index = -1;
                    this.updateButtons();
                },
                updateButtons() {
                    undoBtn.disabled = this.index <= 0;
                    redoBtn.disabled = this.index >= this.stack.length - 1;
                    undoBtn.style.opacity = undoBtn.disabled ? '0.3' : '1';
                    redoBtn.style.opacity = redoBtn.disabled ? '0.3' : '1';
                }
            };

            // ── Palettes ──
            const PALETTES = [
                { color: 'rainbow', name: 'Rainbow' },
                { color: 'hsl(220, 100%, 80%)', name: 'Ice' },
                { color: 'hsl(280, 100%, 80%)', name: 'Violet' },
                { color: 'hsl(30, 100%, 70%)', name: 'Amber' },
                { color: 'hsl(150, 100%, 70%)', name: 'Mint' },
                { color: 'hsl(350, 100%, 75%)', name: 'Rose' },
            ];
            let currentColor = PALETTES[0];
            let customColor = '#ffffff';

            // ── Canvas Setup ──
            function resize() {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvasContainer.getBoundingClientRect();

                canvasStatic.width = rect.width * dpr;
                canvasStatic.height = rect.height * dpr;

                canvasActive.width = rect.width * dpr;
                canvasActive.height = rect.height * dpr;

                // Force a full re-render without transform to ensure crispness
                renderStaticLayer();
            }
            // Debounced resize to avoid trashing performance
            window.addEventListener('resize', debounce(resize, 200));

            // Initial Setup
            resize();
            history.push();
            history.updateButtons();

            // ── Coordinate Mapping ──
            // Maps screen coordinates (clientX/Y) to World coordinates
            // considering both committed state and active gesture.
            function getWorldCoords(e) {
                const rect = canvasContainer.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                // Center-relative screen coords
                const cx = clientX - rect.left - rect.width / 2;
                const cy = clientY - rect.top - rect.height / 2;

                // Remove Gesture transform
                // Visual = (World * Scale + Offset) * GestureScale + GestureOffset
                // We want World.
                // It's cleaner to just rely on the fact that during DRAWING, 
                // we usually don't have a pinch gesture active.
                // So we only unwrap the committed scale/offset.
                // However, if we draw *while* zoomed in via CSS (after commit), 
                // we must respect state.scale.

                // Note: We are NOT supporting drawing while a multi-touch gesture is active.

                return {
                    x: (cx - state.offsetX) / state.scale,
                    y: (cy - state.offsetY) / state.scale
                };
            }

            // ── Viewport / Zoom Logic ──

            function updateVisualTransform() {
                const { gestureScale, gestureX, gestureY } = state;
                // Apply CSS Transform to the container
                // We use translate3d for GPU acceleration
                canvasContainer.style.transform = `translate3d(${gestureX}px, ${gestureY}px, 0) scale(${gestureScale})`;
            }

            const commitTransformDebounced = debounce(() => {
                // 1. Calculate new committed state
                // NewScale = OldScale * GestureScale
                const newScale = clamp(state.scale * state.gestureScale, 0.1, 50);

                // NewOffset = OldOffset * GestureScale + GestureOffset
                // (Approximation for center-based generic transform)
                const newOffsetX = state.offsetX * state.gestureScale + state.gestureX;
                const newOffsetY = state.offsetY * state.gestureScale + state.gestureY;

                state.scale = newScale;
                state.offsetX = newOffsetX;
                state.offsetY = newOffsetY;

                // 2. Reset Gesture
                state.gestureScale = 1;
                state.gestureX = 0;
                state.gestureY = 0;

                // 3. Reset CSS (Instant snap, but we redraw canvas immediately so it looks seamless)
                // We disable transition momentarily if we had any
                canvasContainer.style.transform = 'none';

                // 4. Redraw at high res
                renderStaticLayer();

            }, 250); // Wait 250ms after last movement to commit (crisp snap)


            // ── Input Handling (Unified Pointer) ──

            // Track pointers for multi-touch
            const pointers = new Map();
            let prevPinchDist = 0;
            let pinchCenter = { x: 0, y: 0 };

            canvasContainer.addEventListener('pointerdown', e => {
                canvasContainer.setPointerCapture(e.pointerId);
                pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

                if (pointers.size === 1) {
                    if (e.pointerType === 'touch') {
                        // Delay draw start to see if a second finger lands for pinch-zoom
                        state.touchDelayTimer = setTimeout(() => {
                            if (pointers.size === 1 && !state.drawing) {
                                handleStart(e);
                                state.bufferedEvents.forEach(ev => handleDrawMove(ev));
                            }
                            state.bufferedEvents = [];
                            state.touchDelayTimer = null;
                        }, 80);
                    } else {
                        handleStart(e);
                    }
                } else {
                    // Multi-touch: Cancel pending or active drawing
                    if (state.touchDelayTimer) {
                        clearTimeout(state.touchDelayTimer);
                        state.touchDelayTimer = null;
                        state.bufferedEvents = [];
                    }
                    if (state.drawing) handleEnd(true); // true = isCancelled

                    // Calc initial pinch distance
                    const pts = Array.from(pointers.values());
                    prevPinchDist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
                }
            });

            canvasContainer.addEventListener('pointermove', e => {
                if (!pointers.has(e.pointerId)) return;
                pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });

                const pts = Array.from(pointers.values());

                if (pts.length === 1) {
                    if (state.drawing) {
                        handleDrawMove(e);
                    } else if (state.touchDelayTimer) {
                        state.bufferedEvents.push(e);
                    }
                } else if (pts.length === 2) {
                    // Pinch / Pan Logic
                    const dist = Math.hypot(pts[0].x - pts[1].x, pts[0].y - pts[1].y);
                    const cx = (pts[0].x + pts[1].x) / 2;
                    const cy = (pts[0].y + pts[1].y) / 2;

                    if (prevPinchDist > 0) {
                        const deltaScale = dist / prevPinchDist;

                        // Update visual gesture state
                        // We want to zoom around the center point (cx, cy).
                        // Math is tricky with CSS transforms.
                        // Simplified approach: Just Scale and translate based on center diff?
                        // Let's settle for Center-Zoom + Pan for robustness, 
                        // or just map everything to `gestureScale` and `gestureX/Y`.

                        // Current Scale: state.gestureScale
                        const newScale = state.gestureScale * deltaScale;

                        // To zoom towards a point P:
                        // P_new = P_old * scale + trans
                        // We want P to stay under cursor.

                        state.gestureScale = newScale;
                        // For now, simple pan support:
                        // We add the delta movement of the center
                        // This logic can be improved for "pinching under finger" exactness
                        // but simple scaling + panning is often enough.
                    }

                    prevPinchDist = dist;
                    updateVisualTransform();
                    commitTransformDebounced();
                }
            });

            canvasContainer.addEventListener('pointerup', e => {
                pointers.delete(e.pointerId);
                if (pointers.size < 2) prevPinchDist = 0;

                if (state.touchDelayTimer) {
                    clearTimeout(state.touchDelayTimer);
                    state.touchDelayTimer = null;
                    state.bufferedEvents = [];
                }
                if (state.drawing) handleEnd();
            });

            canvasContainer.addEventListener('pointercancel', e => {
                pointers.delete(e.pointerId);
                if (state.touchDelayTimer) {
                    clearTimeout(state.touchDelayTimer);
                    state.touchDelayTimer = null;
                    state.bufferedEvents = [];
                }
                if (state.drawing) handleEnd(true);
            });

            // Mouse Wheel Zoom
            canvasContainer.addEventListener('wheel', e => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;

                // Accumulate gesture
                state.gestureScale *= delta;

                // Very basic "Zoom to center" logic for wheel
                // (Refining this to "Zoom to mouse" requires tracking mouse pos relative to center)

                updateVisualTransform();
                commitTransformDebounced();
            }, { passive: false });


            // ── Drawing Logic ──

            function handleStart(e) {
                if (e.button !== 0 && e.pointerType === 'mouse') return; // Left click only
                e.preventDefault();
                startTip.classList.add('hidden');

                state.drawing = true;
                document.body.classList.add('drawing');

                const pos = getWorldCoords(e);

                currentStroke = {
                    points: [{ x: pos.x, y: pos.y }],
                    color: currentColor.color === 'rainbow' ? 'rainbow' : currentColor.color,
                    colors: [],
                    lineWidth: state.brushSize,
                    symmetry: state.symmetry,
                    mirror: state.mirrorMode,
                };

                state.hasDrawn = true;
            }

            function handleDrawMove(e) {
                if (!state.drawing || !currentStroke) return;
                const { x, y } = getWorldCoords(e);

                // Throttling: Ignore points too close to the last one
                const lastPt = currentStroke.points[currentStroke.points.length - 1];
                if (lastPt) {
                    const dist = Math.hypot(x - lastPt.x, y - lastPt.y);
                    // Threshold: 2 screen pixels (accounting for scale roughly or just raw units)
                    // If we are zoomed in, 2 units might be very small. 
                    // Let's use a small constant.
                    if (dist < 1.0) return;
                }

                currentStroke.points.push({ x, y });

                // Rainbow color logic
                if (currentStroke.color === 'rainbow') {
                    const segColor = `hsl(${state.hue}, 90%, 65%)`;
                    state.hue = (state.hue + 1.5) % 360;
                    currentStroke.colors.push(segColor);
                }

                // Render just the new segment
                renderLiveSegment(currentStroke);
            }

            function handleEnd(isCancelled = false) {
                if (!state.drawing) return;
                state.drawing = false;
                document.body.classList.remove('drawing');

                // Clear the active layer (it was just a scratchpad)
                // Use a quick clear
                ctxActive.clearRect(0, 0, canvasActive.width, canvasActive.height);

                // Only store the stroke if it wasn't cancelled (e.g. by a pinch)
                // and if it actually has more than one point (a line segment).
                if (!isCancelled && currentStroke && currentStroke.points.length > 1) {
                    strokes.push(currentStroke);
                    history.push();
                    // Permanently draw to static layer
                    // We render JUST this new stroke to the static layer to avoid full redraw
                    renderStaticStroke(currentStroke);
                }
                currentStroke = null;
            }


            // ── Render / Core ──

            function getSmoothPath(points, scale) {
                if (points.length < 2) return null;
                const path = new Path2D();
                path.moveTo(points[0].x * scale, points[0].y * scale);
                for (let i = 1; i < points.length - 1; i++) {
                    const xc = (points[i].x + points[i + 1].x) / 2;
                    const yc = (points[i].y + points[i + 1].y) / 2;
                    path.quadraticCurveTo(points[i].x * scale, points[i].y * scale, xc * scale, yc * scale);
                }
                path.lineTo(points[points.length - 1].x * scale, points[points.length - 1].y * scale);
                return path;
            }

            function renderLiveSegment(stroke) {
                // Draws to Active Layer
                const pts = stroke.points;
                if (pts.length < 2) return;

                const p1 = pts[pts.length - 2];
                const p2 = pts[pts.length - 1]; // current

                const dpr = window.devicePixelRatio || 1;
                const s = state.scale * dpr;
                const ox = state.offsetX * dpr; // Use committed offset
                const oy = state.offsetY * dpr;

                const lw = stroke.lineWidth * s;
                const shadowMul = 2;
                const alpha = 1;

                const cx = canvasActive.width / 2 + ox;
                const cy = canvasActive.height / 2 + oy;
                const angleStep = (Math.PI * 2) / stroke.symmetry;

                ctxActive.lineWidth = lw;
                ctxActive.lineCap = 'round';
                ctxActive.lineJoin = 'round';
                ctxActive.shadowBlur = lw * shadowMul;
                ctxActive.globalAlpha = alpha;

                // Color determination
                let color = stroke.color;
                if (color === 'rainbow') {
                    // Get last color pushed
                    color = stroke.colors[stroke.colors.length - 1] || '#fff';
                }
                ctxActive.strokeStyle = color;
                ctxActive.shadowColor = color;

                ctxActive.save();
                ctxActive.translate(cx, cy);

                for (let i = 0; i < stroke.symmetry; i++) {
                    ctxActive.save();
                    ctxActive.rotate(angleStep * i);

                    ctxActive.beginPath();
                    ctxActive.moveTo(p1.x * s, p1.y * s);
                    ctxActive.lineTo(p2.x * s, p2.y * s);
                    ctxActive.stroke();

                    if (stroke.mirror) {
                        ctxActive.scale(1, -1);
                        ctxActive.beginPath();
                        ctxActive.moveTo(p1.x * s, p1.y * s);
                        ctxActive.lineTo(p2.x * s, p2.y * s);
                        ctxActive.stroke();
                    }
                    ctxActive.restore();
                }
                ctxActive.restore();

                ctxActive.shadowBlur = 0;
                ctxActive.globalAlpha = 1;
            }

            function renderStaticLayer() {
                // Full clear and redraw of Static Layer
                ctxStatic.clearRect(0, 0, canvasStatic.width, canvasStatic.height);
                // Also clear active just in case
                ctxActive.clearRect(0, 0, canvasActive.width, canvasActive.height);

                for (const stroke of strokes) {
                    renderStaticStroke(stroke);
                }
            }

            function renderStaticStroke(stroke) {
                // Draws a single full stroke to the Static Layer
                const dpr = window.devicePixelRatio || 1;
                const s = state.scale * dpr;
                const ox = state.offsetX * dpr;
                const oy = state.offsetY * dpr;

                const cx = canvasStatic.width / 2 + ox;
                const cy = canvasStatic.height / 2 + oy;

                const lw = stroke.lineWidth * s;
                const shadowMul = 2;
                const alpha = 1;
                const angleStep = (Math.PI * 2) / stroke.symmetry;

                ctxStatic.lineWidth = lw;
                ctxStatic.lineCap = 'round';
                ctxStatic.lineJoin = 'round';
                ctxStatic.shadowBlur = lw * shadowMul;
                ctxStatic.globalAlpha = alpha;

                ctxStatic.save();
                ctxStatic.translate(cx, cy);

                // Batched path for solid colors
                if (stroke.color !== 'rainbow') {
                    ctxStatic.strokeStyle = stroke.color;
                    ctxStatic.shadowColor = stroke.color;
                    const path = getSmoothPath(stroke.points, s);

                    if (path) {
                        for (let i = 0; i < stroke.symmetry; i++) {
                            ctxStatic.stroke(path);
                            if (stroke.mirror) {
                                ctxStatic.save();
                                ctxStatic.scale(1, -1);
                                ctxStatic.stroke(path);
                                ctxStatic.restore();
                            }
                            ctxStatic.rotate(angleStep);
                        }
                    }
                } else {
                    // Rainbow: Segment-based rendering
                    const points = stroke.points;
                    for (let i = 0; i < stroke.symmetry; i++) {
                        ctxStatic.save();
                        if (i > 0) ctxStatic.rotate(angleStep * i);

                        // Draw Arm
                        for (let j = 0; j < points.length - 1; j++) {
                            const p1 = points[j];
                            const p2 = points[j + 1];
                            const color = stroke.colors[j] || '#fff';
                            ctxStatic.beginPath();
                            ctxStatic.moveTo(p1.x * s, p1.y * s);
                            ctxStatic.lineTo(p2.x * s, p2.y * s);
                            ctxStatic.strokeStyle = color;
                            ctxStatic.shadowColor = color;
                            ctxStatic.stroke();
                        }

                        if (stroke.mirror) {
                            ctxStatic.scale(1, -1);
                            for (let j = 0; j < points.length - 1; j++) {
                                const p1 = points[j];
                                const p2 = points[j + 1];
                                const color = stroke.colors[j] || '#fff';
                                ctxStatic.beginPath();
                                ctxStatic.moveTo(p1.x * s, p1.y * s);
                                ctxStatic.lineTo(p2.x * s, p2.y * s);
                                ctxStatic.strokeStyle = color;
                                ctxStatic.shadowColor = color;
                                ctxStatic.stroke();
                            }
                        }
                        ctxStatic.restore();
                    }
                }
                ctxStatic.restore();

                ctxStatic.shadowBlur = 0;
                ctxStatic.globalAlpha = 1;
            }

            function requestRender() {
                requestAnimationFrame(renderStaticLayer);
            }




            // ── UI / Helpers ──

            // Re-bind UI events
            buildColorPicker(); // Re-use existing function reference? No, we need to redefine or move it inside.
            // Actually, I am inside a closure, need to define `buildColorPicker`.

            function buildColorPicker() {
                PALETTES.forEach((p, i) => {
                    const el = document.createElement('div');
                    el.className = 'color-option';
                    el.style.background = p.color === 'rainbow'
                        ? 'conic-gradient(#f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)' : p.color;
                    if (i === 0) el.classList.add('selected');
                    el.addEventListener('click', () => selectColor(p, el));
                    colorPicker.appendChild(el);
                });

                // Custom
                const custom = document.createElement('div');
                custom.className = 'color-custom';
                custom.style.background = customColor;
                const input = document.createElement('input');
                input.type = 'color';
                input.value = customColor;
                input.addEventListener('input', e => {
                    customColor = e.target.value;
                    custom.style.background = customColor;
                    selectColor({ color: customColor, name: 'Custom' }, custom);
                });
                custom.appendChild(input);
                colorPicker.appendChild(custom);
            }

            function selectColor(palette, el) {
                document.querySelectorAll('.color-option, .color-custom').forEach(e => e.classList.remove('selected'));
                el.classList.add('selected');
                currentColor = palette;
            }

            function showToast(msg) {
                toast.textContent = msg;
                toast.classList.add('visible');
                setTimeout(() => toast.classList.remove('visible'), 1200);
            }

            symmetryRange.addEventListener('change', e => {
                state.symmetry = parseInt(e.target.value, 10);
            });

            brushRange.addEventListener('change', e => {
                state.brushSize = parseInt(e.target.value, 10);
            });

            mirrorBtn.addEventListener('click', () => {
                state.mirrorMode = !state.mirrorMode;
                mirrorBtn.classList.toggle('active', state.mirrorMode);
                showToast(state.mirrorMode ? 'Mirror On' : 'Mirror Off');
            });



            clearBtn.addEventListener('click', () => {
                if (!state.clearPending) {
                    state.clearPending = true;
                    clearBtn.textContent = 'Sure?';
                    clearBtn.classList.add('danger-confirm');
                    state.clearTimer = setTimeout(() => {
                        state.clearPending = false;
                        clearBtn.textContent = 'Clear';
                        clearBtn.classList.remove('danger-confirm');
                    }, 3000);
                    return;
                }

                clearTimeout(state.clearTimer);
                state.clearPending = false;
                clearBtn.textContent = 'Clear';
                clearBtn.classList.remove('danger-confirm');

                strokes.length = 0;
                history.push();
                renderStaticLayer();
                showToast('Cleared');
            });

            saveBtn.addEventListener('click', () => {
                // Save logic (similar to before)
                const link = document.createElement('a');
                link.download = `mandala-${Date.now()}.png`;
                // Composite Active onto Static for saving if needed (usually active is empty when saving)
                // But just in case, we can draw active on static temp? 
                // No, when saving, we are usually idle. Static is enough.
                link.href = canvasStatic.toDataURL();
                link.click();
            });

            undoBtn.addEventListener('click', () => history.undo());
            redoBtn.addEventListener('click', () => history.redo());

            fullscreenBtn.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        showToast(`Fullscreen error: ${err.message}`);
                    });
                } else {
                    document.exitFullscreen();
                }
            });

            document.addEventListener('fullscreenchange', () => {
                if (document.fullscreenElement) {
                    fullscreenBtn.textContent = '[ - ]';
                    fullscreenBtn.title = 'Exit Fullscreen';
                    fullscreenBtn.classList.add('active');
                } else {
                    fullscreenBtn.textContent = '[ + ]';
                    fullscreenBtn.title = 'Enter Fullscreen';
                    fullscreenBtn.classList.remove('active');
                }
            });

            // Utils
            function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }
            function debounce(fn, ms) {
                let t;
                return (...args) => {
                    clearTimeout(t);
                    t = setTimeout(() => fn(...args), ms);
                };
            }



        })();
    </script>
</body>

</html>